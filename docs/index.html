<!DOCTYPE html>
<html lang="en-US">

<head>
<title>Yutils</title>
<base href="" target="_self" />
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta http-equiv="content-style-type" content="text/css">
<meta http-equiv="content-script-type" content="text/javascript">
<meta http-equiv="content-language" content="en-us">
<meta name="application-name" content="Yutils">
<meta name="author" content="Youka">
<meta name="description" content="An ASS typeset utilities library">
<meta name="keywords" content="lua,library,utilities,advanced,substation,alpha">
<meta name="robots" content="index,nofollow">
<link rel="icon" type="image/png" href="favicon.png">
<link rel="stylesheet" type="text/css" href="style.css" media="screen">
<script type="text/javascript" src="toy.js"></script>
</head>

<body>
<noscript>
For some functionality javascript is required! Please activate it if you want to use everything.
</noscript>
<h1>Yutils<span>An ASS typeset utilities library</span></h1>
<hr>
<div class="contents"></div>
<div class="section" id="Description">
<b>Yutils</b> is a <a href="http://lua.org">Lua</a> library with functions for media decoding, shape manipulation, advanced math, utf-8 coded texts, ASS (Advanced Substation Alpha) script parsing and with some other small helpers.<br>
She was written to run with <a href="http://luajit.org/luajit.html">LuaJIT</a>, working with Lua 5.2 syntax and <a href="http://en.wikipedia.org/wiki/Foreign_function_interface">FFI</a>.<br>
</div>
<div class="section" id="Install">
Yutils runs without (additional) dependencies with <b>LuaJIT 2</b> as interpreter, though some functionality might require to install a library. So far, just some decodings, like fonts and PNG images, could lead you to some handwork.<br>
The base is just <u>one Lua script</u>, not more. Include and use it in your project, no frills beside.<br>
<br>
<u>What you can extend:</u>
<ul>
<li>On Unix, <a href="http://pango.org/">pango</a>, <a href="http://cairographics.org/">cairo</a> and <a href="http://fontconfig.org">fontconfig</a> is needed for font support (most distributions should have them as system libraries).</li>
<li><a href="http://www.libpng.org/pub/png/libpng.html">libpng</a> is needed for PNG support of the image reader.</li>
</ul>
<br>
How Yutils work can be influenced by changes in her configuration which is a few local variables at the code beginning (directly after the first comment lines).<br>
For example, lowering the value of <i>CURVE_TOLERANCE</i> could cause to smoother edges on curve flattening, same time resulting in more output lines and slower calculation. The default values are already well considered in weight of enough usefulness and perfection insanity, so be careful when changing anything (values don't get checked, so you could break things).
</div>
<div class="section" id="Usage">
Yutils consists of functions only, packed in sublibrary tables, those packed in one library table which you get from library file loading.<br>
<div class="code">local Yutils = require("Yutils")
local Ymath = Yutils.math

print(Ymath.distance(1,1))
-- 1.4142135623731</div>
</div>
<div class="section" id="Functions">
<div class="function">
new_table = table.copy(t[, depth])<br>
Copies elements (recursively) of table <span class="function_parameters">t</span> into returned table <span class="function_return">new_table</span>.<br>
<span class="function_parameters">depth</span> can limit the number of recursive passes, so value 1 results in a shallow copy.
</div>
<div class="function">
table_description = table.tostring(t)<br>
Converts table <span class="function_parameters">t</span> into readable string <span class="function_return">table_description</span> (mainly useful for debugging).
</div>
<div class="function">
range = utf8.charrange(s, i)<br>
Returns byte range of unicode character in string <span class="function_parameters">s</span> at position <span class="function_parameters">i</span>.
</div>
<div class="function">
chars_iter = utf8.chars(s)<br>
Creates iterator function through unicode characters of string <span class="function_parameters">s</span>.<br>
Every iteration pass returns character index + string or nil on end.
</div>
<div class="function">
length = utf8.len(s)<br>
Returns unicode characters number of string <span class="function_parameters">s</span>.
</div>
<div class="function">
c0x0, c0y0, c0x1, c0y1, c0x2, c0y2, c0x3, c0y3[, c1x0, c1y0, c1x1, c1y1, c1x2, c1y2, c1x3, c1y3[, c2x0, c2y0, c2x1, c2y1, c2x2, c2y2, c2x3, c2y3[, c3x0, c3y0, c3x1, c3y1, c3x2, c3y2, c3x3, c3y3]]] = math.arc_curve(x, y, cx, cy, angle)<br>
Converts arc data to bezier curves.<br>
<span class="function_parameters">x</span> & <span class="function_parameters">y</span> is the arc starting point, <span class="function_parameters">cx</span> & <span class="function_parameters">cy</span> the arc center and <span class="function_parameters">angle</span> the angle in degree of the arc.<br>
For every 90Â° one curve is generated, so a maximum of 4 curves can span a circle. Curves are 3rd order bezier curves, defined as <span class="function_return">c&ltCURVE_INDEX&gtx|y&ltPOINT_INDEX&gt</span>.
</div>
<div class="function">
x, y, z = math.bezier(pct, pts)<br>
Calculates a point on a bezier curve of any order.<br>
<span class="function_parameters">pct</span> is the position on the curve in range 0&lt=x&lt=1. <span class="function_parameters">pts</span> is a table of tables, each one containing 2 or 3 numbers as curve point.
</div>
<div class="function">
MATRIX = math.create_matrix()<br>
Creates a 3D matrix object (for usage, see following functions).
</div>
<div class="function">
matrix_fields = MATRIX.get_data()<br>
Returns a table with 16 numbers, presenting all matrix fields.<br>
<table class="grid" style="float: left;">
<tr><td>1</td><td>5</td><td>9</td><td>13</td></tr>
<tr><td>2</td><td>6</td><td>10</td><td>14</td></tr>
<tr><td>3</td><td>7</td><td>11</td><td>15</td></tr>
<tr><td>4</td><td>8</td><td>12</td><td>16</td></tr>
</table>
<table class="grid" style="float: left; margin-left: 5px; font-size: 10px;">
<tr><td>x0x1</td><td>y0x1</td><td>z0x1</td><td>w0x1</td></tr>
<tr><td>x0y1</td><td>y0y1</td><td>z0y1</td><td>w0y1</td></tr>
<tr><td>x0z1</td><td>y0z1</td><td>z0z1</td><td>w0z1</td></tr>
<tr><td>x0w1</td><td>y0w1</td><td>z0w1</td><td>w0w1</td></tr>
</table>
</div>
<div class="function">
MATRIX = MATRIX.set_data(matrix_fields)<br>
Sets matrix fields. For more, see <a href="#MATRIX.get_data">MATRIX.get_data</a>.
</div>
<div class="function">
MATRIX = MATRIX.identity()<br>
Resets matrix to identity.
</div>
<div class="function">
MATRIX = MATRIX.multiply(matrix_fields)<br>
Multiplies another matrix as table/raw data to this matrix. This way, matrix properties get prepended. For more, see <a href="#MATRIX.get_data">MATRIX.get_data</a>.
</div>
<div class="function">
MATRIX = MATRIX.translate(x, y, z)<br>
Applies a translation to the matrix.
</div>
<div class="function">
MATRIX = MATRIX.scale(x, y, z)<br>
Applies a scale to the matrix.
</div>
<div class="function">
MATRIX = MATRIX.rotate(axis, angle)<br>
Applies a rotation to the matrix. <span class="function_parameters">axis</span> can be "x", "y" or "z", <span class="function_parameters">angle</span> is in degree.
</div>
<div class="function">
[MATRIX] = MATRIX.inverse()<br>
Inverses the matrix. This might fail, so nil will be returned.
</div>
<div class="function">
rx, ry, rz, rw = MATRIX.transform(x, y, z[, w])<br>
Multiplies a point with the matrix.
</div>
<div class="function">
degree = math.degree(x1, y1, z1, x2, y2, z2)<br>
Calculates the degree between vectors <span class="function_parameters">x1|y1|z1</span> and <span class="function_parameters">x2|y2|z3</span>.
</div>
<div class="function">
length = math.distance(x, y[, z])<br>
Calculates length of given vector.
</div>
<div class="function">
rx, ry, rz = math.ortho(x1, y1, z1, x2, y2, z2)<br>
Calculates the orthogonal vector to vectors <span class="function_parameters">x1|y1|z1</span> and <span class="function_parameters">x2|y2|z3</span>.
</div>
<div class="function">
r = math.randomsteps(min, max, step)<br>
Generates randomly a number in range <span class="function_parameters">min</span> to <span class="function_parameters">max</span> with gap size <span class="function_parameters">step</span> between numbers.
</div>
<div class="function">
r = math.round(x[, dec])<br>
Rounds <span class="function_parameters">x</span> to nearest integer. Optionally, <span class="function_parameters">dec</span> defines the position behind decimal point to round to.
</div>
<div class="function">
rx, ry, rz = math.stretch(x, y, z, length)<br>
Stretches vector <span class="function_parameters">x|y|z</span> to length <span class="function_parameters">length</span>.
</div>
<div class="function">
r = math.trim(x, min, max)<br>
If <span class="function_parameters">x</span> is smaller than <span class="function_parameters">min</span>, returns <span class="function_parameters">min</span>. If <span class="function_parameters">x</span> is greater than <span class="function_parameters">max</span>, returns <span class="function_parameters">max</span>. Otherwise returns <span class="function_parameters">x</span>.
</div>
<div class="function">
frames_iter = algorithm.frames(starts, ends, dur)<br>
Creates iterator function for frames in range <span class="function_parameters">starts</span> to <span class="function_parameters">ends</span> with step size <span class="function_parameters">dur</span>.<br>
For each frame, the start, end, index and number of all frames becomes available.
</div>
<div class="function">
lines_iter = algorithm.lines(text)<br>
Creates iterator functions through lines of text <span class="function_parameters">text</span>.<br>
All 3 sorts of line endings (<i>CR, LF, CRLF</i>) will be considered.
</div>
<div class="function">
x0, y0, x1, y1 = shape.bounding(shape)<br>
Calculates the bounding box of shape <span class="function_parameters">shape</span>.<br>
<span class="function_parameters">x0|y0</span> is the upper-left and <span class="function_parameters">x1|y1</span> the lower-right corner of the rectangle.
</div>
<div class="function">
shapes = shape.detect(width, height, data[, compare_func])<br>
Traces shapes in 2D data.<br>
<span class="function_parameters">width</span> and <span class="function_parameters">height</span> defines vector lengths => how to read elements in data table <span class="function_parameters">data</span>.<br>
<span class="function_parameters">compare_func</span> can be defined as comparison function, useful for non-flat data elements.<br>
Each entry in returned table <span class="function_return">shapes</span> contains following fields:
<ul>
<li><b>value</b>: unique value in <span class="function_parameters">data</span></li>
<li><b>shapes</b>: table with shapes (as strings), covering <b>value</b> in <span class="function_parameters">data</span></li>
</ul>
</div>
<div class="function">
new_shape = shape.filter(shape, filter)<br>
Filters points of shape <span class="function_parameters">shape</span> by function <span class="function_parameters">filter</span> and returns a new one.<br>
<span class="function_parameters">filter</span> receives point coordinates <b>x</b> and <b>y</b> as well as the point type and have to return 2 numbers, replacing <b>x</b> and <b>y</b>.
</div>
<div class="function">
flattened_shape = shape.flatten(shape)<br>
Converts all 3rd order bezier curves in shape <span class="function_parameters">shape</span> to lines, creating a new shape.
</div>
<div class="function">
new_shape = shape.glue(src_shape, dst_shape[, transform_callback])<br>
Projects shape <span class="function_parameters">src_shape</span> with his bottom on the first figure of shape <span class="function_parameters">dst_shape</span>, returned as new shape. <span class="function_parameters">src_shape</span> gets stretched to fit on <span class="function_parameters">dst_shape</span>.<br>
<span class="function_parameters">transform_callback</span> can be defined as callback function, receiving the position on <span class="function_parameters">dst_shape</span> in range 0&lt=x&lt=1 and the orthogonal offset, having to return the replacement.
</div>
<div class="function">
new_shape = shape.move(shape, x, y)<br>
Shifts points of shape <span class="function_parameters">shape</span> horizontally by <span class="function_parameters">x</span> and vertically by <span class="function_parameters">y</span>, creating a new shape.
</div>
<div class="function">
new_shape = shape.split(shape, max_len)<br>
Splits lines of shape <span class="function_parameters">shape</span> into shorter ones to fix to maximal line length of <span class="function_parameters">max_len</span>, creating a new shape.
</div>
<div class="function">
outline_shape = shape.to_outline(shape, width_xy[, width_y])<br>
Converts shape <span class="function_parameters">shape</span> from his filling to the stroke with horizontal width <span class="function_parameters">width_xy</span> and vertical width <span class="function_parameters">width_y</span>, returned as new shape. If <span class="function_parameters">width_y</span> isn't defined, <span class="function_parameters">width_xy</span> stands for both.
</div>
<div class="function">
pixels = shape.to_pixels(shape)<br>
Renders shape <span class="function_parameters">shape</span> and returns pixels.<br>
<span class="function_return">pixels</span> is a table of single pixels, each one with following fields:
<ul>
<li><b>x</b>: horizontal position</li>
<li><b>y</b>: vertical position</li>
<li><b>alpha</b>: opacity in range 0&lt;=x&lt;=255</li>
</ul>
</div>
<div class="function">
transformed_shape = shape.transform(shape, MATRIX)<br>
Applies a matrix (see <a href="#math.create_matrix">math.create_matrix</a>) on shape points of <span class="function_parameters">shape</span>, creating a new shape.
</div>
<div class="function">
ms_ass = ass.convert_time(ass_ms)<br>
Converts time between numeric and ASS presentation.<br>
<span class="function_parameters">ass_ms</span> can be a string in ASS format <b>H:MM:SS.XX</b> (H=Hours, M=Minutes, S=Seconds, X=Milliseconds*10) or milliseconds as number.<br>
<span class="function_return">ms_ass</span> becomes the equivalent of <span class="function_parameters">ass_ms</span>.
</div>
<div class="function">
a_r_ass[, rg, rb[, ra]] = ass.convert_coloralpha(ass_r_a[, g, b[, a]])<br>
Converts color, alpha or color+alpha between numeric and ASS presentation.<br>
<span class="function_parameters">ass_r_a</span> can be a string as ASS color (<b>&amp;H<font color=blue>FF</font><font color=green>FF</font><font color=red>FF</font>&amp;</b>), alpha (<b>&amp;H<font color=grey>FF</font>&amp;</b>) or both (<b>&amp;H<font color=grey>FF</font><font color=blue>FF</font><font color=green>FF</font><font color=red>FF</font></b>) as well as the color strength of red or alpha in range 0&lt;=x&lt;=255.<br>
<span class="function_parameters">g</span> is green, <span class="function_parameters">b</span> is blue, <span class="function_parameters">a</span> is alpha, all color strengths in range 0&lt;=x&lt;=255 too.<br>
<span class="function_return">a_r_ass[, rg, rb[, ra]]</span> becomes the equivalent of <span class="function_parameters">ass_r_a[, g, b[, a]]</span>.
</div>
<div class="function">
coloralpha = ass.interpolate_coloralpha(pct, ...)<br>
Interpolates between multiple ASS color, alpha or color+alpha <span class="function_parameters">...</span> and calculates the value at position <span class="function_parameters">pct</span> with range 0&lt;=x&lt;=1.
</div>
<div class="function">
PARSER = ass.create_parser([ass_text])<br>
TODO
</div>
<div class="function">
accepted = PARSER.parse_line(line)<br>
TODO
</div>
<div class="function">
meta = PARSER.meta()<br>
TODO
</div>
<div class="function">
styles = PARSER.styles()<br>
TODO
</div>
<div class="function">
dialogs = PARSER.dialogs([extended])<br>
TODO
</div>
<div class="function">
BMP_READER = decode.create_bmp_reader(filename)<br>
TODO
</div>
<div class="function">
file_size = BMP_READER.file_size()<br>
TODO
</div>
<div class="function">
width = BMP_READER.width()<br>
TODO
</div>
<div class="function">
height = BMP_READER.height()<br>
TODO
</div>
<div class="function">
bit_depth = BMP_READER.bit_depth()<br>
TODO
</div>
<div class="function">
data_size = BMP_READER.data_size()<br>
TODO
</div>
<div class="function">
row_size = BMP_READER.row_size()<br>
TODO
</div>
<div class="function">
is_bottom_up = BMP_READER.bottom_up()<br>
TODO
</div>
<div class="function">
data_raw = BMP_READER.data_raw()<br>
TODO
</div>
<div class="function">
data_packed = BMP_READER.data_packed()<br>
TODO
</div>
<div class="function">
data_ass_text = BMP_READER.data_text()<br>
TODO
</div>
<div class="function">
WAV_READER = decode.create_wav_reader(filename)<br>
TODO
</div>
<div class="function">
file_size = WAV_READER.file_size()<br>
TODO
</div>
<div class="function">
channels = WAV_READER.channels_number()<br>
TODO
</div>
<div class="function">
sample_rate = WAV_READER.sample_rate()<br>
TODO
</div>
<div class="function">
byte_rate = WAV_READER.byte_rate()<br>
TODO
</div>
<div class="function">
block_align = WAV_READER.block_align()<br>
TODO
</div>
<div class="function">
bits_per_sample = WAV_READER.bits_per_sample()<br>
TODO
</div>
<div class="function">
samples_number = WAV_READER.samples_per_channel()<br>
TODO
</div>
<div class="function">
min_amplitude, max_amplitude = WAV_READER.min_max_amplitude()<br>
TODO
</div>
<div class="function">
sample = WAV_READER.sample_from_ms(ms)<br>
TODO
</div>
<div class="function">
ms = WAV_READER.ms_from_sample(sample)<br>
TODO
</div>
<div class="function">
position = WAV_READER.position([pos])<br>
TODO
</div>
<div class="function">
samples = WAV_READER.samples_interlaced(n)<br>
TODO
</div>
<div class="function">
samples = WAV_READER.samples(n)<br>
TODO
</div>
<div class="function">
FREQ_ANALYZER = decode.create_frequency_analyzer(samples, sample_rate)<br>
TODO
</div>
<div class="function">
frequencies = FREQ_ANALYZER.frequencies()<br>
TODO
</div>
<div class="function">
weight = FREQ_ANALYZER.frequency_weight(freq)<br>
TODO
</div>
<div class="function">
weight = FREQ_ANALYZER.frequency_range_weight(freq_min, freq_max)<br>
TODO
</div>
<div class="function">
FONT_HANDLE = decode.create_font(family, bold, italic, underline, strikeout, size[, xscale][, yscale][, hspace])<br>
TODO
</div>
<div class="function">
metrics = FONT_HANDLE.metrics()<br>
TODO
</div>
<div class="function">
extents = FONT_HANDLE.text_extents(text)<br>
TODO
</div>
<div class="function">
shape = FONT_HANDLE.text_to_shape(text)<br>
TODO
</div>
<div class="function">
fonts_list = decode.list_fonts([with_filenames])<br>
Returns a list of system installed fonts.<br>
<span class="function_return">fonts_list</span> is a table, each entry one font. Fonts contain following fields:
<ul>
<li><b>name</b>: short fontname</li>
<li><b>longname</b>: full fontname</li>
<li><b>style</b>: font style</li>
<li><b>type</b>: font storage type</li>
<li><b>file</b>: font file (<span class="function_parameters">with_filenames</span> must be true; successfull extraction isn't ensured)</li>
</ul>
</div>
</div>
</body>

</html>