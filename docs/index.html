<!DOCTYPE html>
<html lang="en-US">

<head>
<title>Yutils</title>
<base href="" target="_self" />
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta http-equiv="content-style-type" content="text/css">
<meta http-equiv="content-script-type" content="text/javascript">
<meta http-equiv="content-language" content="en-us">
<meta name="application-name" content="Yutils">
<meta name="author" content="Youka">
<meta name="description" content="An ASS typeset utilities library">
<meta name="keywords" content="lua,library,utilities,advanced,substation,alpha">
<meta name="robots" content="index,nofollow">
<link rel="icon" type="image/png" href="favicon.png">
<link rel="stylesheet" type="text/css" href="style.css" media="screen">
<script type="text/javascript" src="toy.js"></script>
</head>

<body>
<noscript>
For some functionality javascript is required! Please activate it if you want to use everything.
</noscript>
<h1>Yutils<span>An ASS typeset utilities library</span></h1>
<hr>
<div class="contents"></div>
<div class="section" id="Description">
<b>Yutils</b> is a <a href="http://lua.org">Lua</a> library with functions for media decoding, shape manipulation, advanced math, utf-8 coded texts, ASS (Advanced Substation Alpha) script parsing and with some other small helpers.<br>
She was written to run with <a href="http://luajit.org/luajit.html">LuaJIT</a>, working with Lua 5.2 syntax and <a href="http://en.wikipedia.org/wiki/Foreign_function_interface">FFI</a>.<br>
</div>
<div class="section" id="Install">
Yutils runs without (additional) dependencies with <b>LuaJIT 2</b> as interpreter, though some functionality might require to install a library. So far, just some decodings, like fonts and PNG images, could lead you to some handwork.<br>
The base is just <u>one Lua script</u>, not more. Include and use it in your project, no frills beside.<br>
<br>
<u>What you can extend:</u>
<ul>
<li>On Unix, <a href="http://pango.org/">pango</a>, <a href="http://cairographics.org/">cairo</a> and <a href="http://fontconfig.org">fontconfig</a> is needed for font support (most distributions should have them as system libraries).</li>
<li><a href="http://www.libpng.org/pub/png/libpng.html">libpng</a> is needed for PNG support of the image reader.</li>
</ul>
<br>
How Yutils work can be influenced by changes in her configuration which is a few local variables at the code beginning (directly after the first comment lines).<br>
For example, lowering the value of <i>CURVE_TOLERANCE</i> could cause to smoother edges on curve flattening, same time resulting in more output lines and slower calculation. The default values are already well considered in weight of enough usefulness and perfection insanity, so be careful when changing anything (values don't get checked, so you could break things).
</div>
<div class="section" id="Usage">
Yutils consists of functions only, packed in sublibrary tables, those packed in one library table which you get from library file loading.<br>
<div class="code">local Yutils = require("Yutils")
local Ymath = Yutils.math

print(Ymath.distance(1,1))
-- 1.4142135623731</div>
</div>
<div class="section" id="Functions">
<div class="function">
new_table = table.copy(t[, depth])<br>
Copies elements (recursively) of table <span class="function_parameters">t</span> into returned table <span class="function_return">new_table</span>.<br>
<span class="function_parameters">depth</span> can limit the number of recursive passes, so value 1 results in a shallow copy.
</div>
<div class="function">
table_description = table.tostring(t)<br>
Converts table <span class="function_parameters">t</span> into readable string <span class="function_return">table_description</span> (mainly useful for debugging).
</div>
<div class="function">
range = utf8.charrange(s, i)<br>
Returns byte range of unicode character in string <span class="function_parameters">s</span> at position <span class="function_parameters">i</span>.
</div>
<div class="function">
chars_iter = utf8.chars(s)<br>
Creates iterator function through unicode characters of string <span class="function_parameters">s</span>.<br>
Every iteration pass returns character index + string or nil on end.
</div>
<div class="function">
length = utf8.len(s)<br>
Returns unicode characters number of string <span class="function_parameters">s</span>.
</div>
<div class="function">
c0x0, c0y0, c0x1, c0y1, c0x2, c0y2, c0x3, c0y3[, c1x0, c1y0, c1x1, c1y1, c1x2, c1y2, c1x3, c1y3[, c2x0, c2y0, c2x1, c2y1, c2x2, c2y2, c2x3, c2y3[, c3x0, c3y0, c3x1, c3y1, c3x2, c3y2, c3x3, c3y3]]] = math.arc_curve(x, y, cx, cy, angle)<br>
Converts arc data to bezier curves.<br>
<span class="function_parameters">x</span> & <span class="function_parameters">y</span> is the arc starting point, <span class="function_parameters">cx</span> & <span class="function_parameters">cy</span> the arc center and <span class="function_parameters">angle</span> the angle in degree of the arc.<br>
For every 90Â° one curve is generated, so a maximum of 4 curves can span a circle. Curves are 3rd order bezier curves, defined as <span class="function_return">c&ltCURVE_INDEX&gtx|y&ltPOINT_INDEX&gt</span>.
</div>
<div class="function">
x, y, z = math.bezier(pct, pts)<br>
Calculates a point on a bezier curve of any order.<br>
<span class="function_parameters">pct</span> is the position on the curve in range 0&lt=x&lt=1. <span class="function_parameters">pts</span> is a table of tables, each one containing 2 or 3 numbers as curve point.
</div>
<div class="function">
MATRIX = math.create_matrix()<br>
Creates a 3D matrix object (for usage, see following functions).
</div>
<div class="function">
matrix_fields = MATRIX.get_data()<br>
Returns a table with 16 numbers, presenting all matrix fields.<br>
<table class="grid" style="float: left;">
<tr><td>1</td><td>5</td><td>9</td><td>13</td></tr>
<tr><td>2</td><td>6</td><td>10</td><td>14</td></tr>
<tr><td>3</td><td>7</td><td>11</td><td>15</td></tr>
<tr><td>4</td><td>8</td><td>12</td><td>16</td></tr>
</table>
<table class="grid" style="float: left; margin-left: 5px; font-size: 10px;">
<tr><td>x0x1</td><td>y0x1</td><td>z0x1</td><td>w0x1</td></tr>
<tr><td>x0y1</td><td>y0y1</td><td>z0y1</td><td>w0y1</td></tr>
<tr><td>x0z1</td><td>y0z1</td><td>z0z1</td><td>w0z1</td></tr>
<tr><td>x0w1</td><td>y0w1</td><td>z0w1</td><td>w0w1</td></tr>
</table>
</div>
<div class="function">
MATRIX = MATRIX.set_data(matrix_fields)<br>
Sets matrix fields. For more, see <a href="#MATRIX.get_data">MATRIX.get_data</a>.
</div>
<div class="function">
MATRIX = MATRIX.identity()<br>
Resets matrix to identity.
</div>
<div class="function">
MATRIX = MATRIX.multiply(matrix_fields)<br>
Multiplies another matrix as table/raw data to this matrix. This way, matrix properties get prepended. For more, see <a href="#MATRIX.get_data">MATRIX.get_data</a>.
</div>
<div class="function">
MATRIX = MATRIX.translate(x, y, z)<br>
Applies a translation to the matrix.
</div>
<div class="function">
MATRIX = MATRIX.scale(x, y, z)<br>
Applies a scale to the matrix.
</div>
<div class="function">
MATRIX = MATRIX.rotate(axis, angle)<br>
Applies a rotation to the matrix. <span class="function_parameters">axis</span> can be "x", "y" or "z", <span class="function_parameters">angle</span> is in degree.
</div>
<div class="function">
[MATRIX] = MATRIX.inverse()<br>
Inverses the matrix. This might fail, so nil will be returned.
</div>
<div class="function">
rx, ry, rz, rw = MATRIX.transform(x, y, z[, w])<br>
Multiplies a point with the matrix.
</div>
<div class="function">
degree = math.degree(x1, y1, z1, x2, y2, z2)<br>
Calculates the degree between vectors <span class="function_parameters">x1|y1|z1</span> and <span class="function_parameters">x2|y2|z3</span>.
</div>
<div class="function">
length = math.distance(x, y[, z])<br>
Calculates length of given vector.
</div>
<div class="function">
rx, ry, rz = math.ortho(x1, y1, z1, x2, y2, z2)<br>
Calculates the orthogonal vector to vectors <span class="function_parameters">x1|y1|z1</span> and <span class="function_parameters">x2|y2|z3</span>.
</div>
<div class="function">
r = math.randomsteps(min, max, step)<br>
Generates randomly a number in range <span class="function_parameters">min</span> to <span class="function_parameters">max</span> with gap size <span class="function_parameters">step</span> between numbers.
</div>
<div class="function">
r = math.round(x[, dec])<br>
Rounds <span class="function_parameters">x</span> to nearest integer. Optionally, <span class="function_parameters">dec</span> defines the position behind decimal point to round to.
</div>
<div class="function">
rx, ry, rz = math.stretch(x, y, z, length)<br>
Stretches vector <span class="function_parameters">x|y|z</span> to length <span class="function_parameters">length</span>.
</div>
<div class="function">
r = math.trim(x, min, max)<br>
If <span class="function_parameters">x</span> is smaller than <span class="function_parameters">min</span>, returns <span class="function_parameters">min</span>. If <span class="function_parameters">x</span> is greater than <span class="function_parameters">max</span>, returns <span class="function_parameters">max</span>. Otherwise returns <span class="function_parameters">x</span>.
</div>
<div class="function">
frames_iter = algorithm.frames(starts, ends, dur)<br>
TODO
</div>
<div class="function">
lines_iter = algorithm.lines(text)<br>
TODO
</div>
<div class="function">
x0, y0, x1, y1 = shape.bounding(shape)<br>
TODO
</div>
<div class="function">
shapes = shape.detect(width, height, data[, compare_func])<br>
TODO
</div>
<div class="function">
new_shape = shape.filter(shape, filter)<br>
TODO
</div>
<div class="function">
flattened_shape = shape.flatten(shape)<br>
TODO
</div>
<div class="function">
new_shape = shape.glue(src_shape, dst_shape[, transform_callback])<br>
TODO
</div>
<div class="function">
new_shape = shape.move(shape, x, y)<br>
TODO
</div>
<div class="function">
new_shape = shape.split(shape, max_len)<br>
TODO
</div>
<div class="function">
outline_shape = shape.to_outline(shape, width_xy[, width_y])<br>
TODO
</div>
<div class="function">
pixels = shape.to_pixels(shape)<br>
TODO
</div>
<div class="function">
transformed_shape = shape.transform(shape, MATRIX)<br>
TODO
</div>
<div class="function">
ms_ass = ass.convert_time(ass_ms)<br>
TODO
</div>
<div class="function">
a_r_ass[, rg, rb[, ra]] = ass.convert_coloralpha(ass_r_a[, g, b[, a]])<br>
TODO
</div>
<div class="function">
coloralpha = ass.interpolate_coloralpha(pct, ...)<br>
TODO
</div>
<div class="function">
PARSER = ass.create_parser([ass_text])<br>
TODO
</div>
<div class="function">
accepted = PARSER.parse_line(line)<br>
TODO
</div>
<div class="function">
meta = PARSER.meta()<br>
TODO
</div>
<div class="function">
styles = PARSER.styles()<br>
TODO
</div>
<div class="function">
dialogs = PARSER.dialogs([extended])<br>
TODO
</div>
<div class="function">
BMP_READER = decode.create_bmp_reader(filename)<br>
TODO
</div>
<div class="function">
file_size = BMP_READER.file_size()<br>
TODO
</div>
<div class="function">
width = BMP_READER.width()<br>
TODO
</div>
<div class="function">
height = BMP_READER.height()<br>
TODO
</div>
<div class="function">
bit_depth = BMP_READER.bit_depth()<br>
TODO
</div>
<div class="function">
data_size = BMP_READER.data_size()<br>
TODO
</div>
<div class="function">
row_size = BMP_READER.row_size()<br>
TODO
</div>
<div class="function">
is_bottom_up = BMP_READER.bottom_up()<br>
TODO
</div>
<div class="function">
data_raw = BMP_READER.data_raw()<br>
TODO
</div>
<div class="function">
data_packed = BMP_READER.data_packed()<br>
TODO
</div>
<div class="function">
data_ass_text = BMP_READER.data_text()<br>
TODO
</div>
<div class="function">
WAV_READER = decode.create_wav_reader(filename)<br>
TODO
</div>
<div class="function">
file_size = WAV_READER.file_size()<br>
TODO
</div>
<div class="function">
channels = WAV_READER.channels_number()<br>
TODO
</div>
<div class="function">
sample_rate = WAV_READER.sample_rate()<br>
TODO
</div>
<div class="function">
byte_rate = WAV_READER.byte_rate()<br>
TODO
</div>
<div class="function">
block_align = WAV_READER.block_align()<br>
TODO
</div>
<div class="function">
bits_per_sample = WAV_READER.bits_per_sample()<br>
TODO
</div>
<div class="function">
samples_number = WAV_READER.samples_per_channel()<br>
TODO
</div>
<div class="function">
min_amplitude, max_amplitude = WAV_READER.min_max_amplitude()<br>
TODO
</div>
<div class="function">
sample = WAV_READER.sample_from_ms(ms)<br>
TODO
</div>
<div class="function">
ms = WAV_READER.ms_from_sample(sample)<br>
TODO
</div>
<div class="function">
position = WAV_READER.position([pos])<br>
TODO
</div>
<div class="function">
samples = WAV_READER.samples_interlaced(n)<br>
TODO
</div>
<div class="function">
samples = WAV_READER.samples(n)<br>
TODO
</div>
<div class="function">
FREQ_ANALYZER = decode.create_frequency_analyzer(samples, sample_rate)<br>
TODO
</div>
<div class="function">
frequencies = FREQ_ANALYZER.frequencies()<br>
TODO
</div>
<div class="function">
weight = FREQ_ANALYZER.frequency_weight(freq)<br>
TODO
</div>
<div class="function">
weight = FREQ_ANALYZER.frequency_range_weight(freq_min, freq_max)<br>
TODO
</div>
<div class="function">
FONT_HANDLE = decode.create_font(family, bold, italic, underline, strikeout, size[, xscale][, yscale][, hspace])<br>
TODO
</div>
<div class="function">
metrics = FONT_HANDLE.metrics()<br>
TODO
</div>
<div class="function">
extents = FONT_HANDLE.text_extents(text)<br>
TODO
</div>
<div class="function">
shape = FONT_HANDLE.text_to_shape(text)<br>
TODO
</div>
<div class="function">
fonts_list = decode.list_fonts([with_filenames])<br>
TODO
</div>
</div>
</body>

</html>